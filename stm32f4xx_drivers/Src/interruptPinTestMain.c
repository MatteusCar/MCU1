/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f407xx.h>
#include <stdio.h>
#include <string.h>

void delay()
{
	for(uint32_t i=0; i<500000; i++);
}

void delay2()
{
	for(uint32_t i=0; i<500000/2; i++);
}

#define HIGH 1
#define BTN_PRSSD HIGH

int main(void)
{
	GPIO_Handle_t GpioLed, GpioBtn;

	//copia o valor do meio em todas as entradas do espaço de memória passado, no caso, o GpioLed.
	//É uma boa prática fazer isso, porque a variável inicia sem lixo da memória
	memset(&GpioLed, 0, sizeof(GpioLed));
	memset(&GpioBtn, 0, sizeof(GpioBtn));

	GpioLed.pGPIOx = GPIOD;                                      //GPIOD
	GpioLed.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_12;         //GPIOD12
	GpioLed.GPIO_PinConfig.GPIO_PinMode =   GPIO_MODE_OUT;       //OUTPUT
	GpioLed.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_LOW;       //LOW Transition between Low and High
	GpioLed.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;     //Output with Push Pull
	GpioLed.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PU_PD;  //Without PullUp or PullDown

	PeriClockControl(GPIOD, ENABLE); //faz um enable do clock daquele GPIO (basicamente um enable do barramento de clock (RCC) desse GPIO)
	GPIO_Init(&GpioLed);

	GpioBtn.pGPIOx = GPIOD;
	GpioBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_5;            //
	GpioBtn.GPIO_PinConfig.GPIO_PinMode =   GPIO_MODE_IT_FT;       //INTERRUPT, falling edge trigger
	GpioBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;        //Fast Transition between Low and High
	//GpioBtn.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;     //Output with Push Pull - nessse caso é irrelevante pois é uma entrada
	GpioBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PU;          //With PullUp

	PeriClockControl(GPIOD, ENABLE); //faz um enable do clock daquele GPIO (basicamente um enable do barramento de clock (RCC) desse GPIO)
	GPIO_Init(&GpioBtn);

	//Agora temos que fazer as configurações da IRQ (dizer qual seu IRQ number e se será habilitado ou desabilitado e prioridade)
	GPIO_IRQPriorityConfig(IRQ_NO_EXTI9_5, 15);       //Como IRQ_NO_EXTI9_5 = 23 por definição, então IRQ_NO_EXTI9_5/4 = 5 (quociente da divisão inteira), deveremos colocar o número 15 no IPR5
	GPIO_IRQInterruptConfig(IRQ_NO_EXTI9_5, ENABLE);  //Lembrando que a interrupção pelo pino 0 chama a IRQ de numero 6, a interrupção no pino 1 chama a IRQ de numero 7
	                                                  //e assim por diante até a número 4, mas de 5 a 9 chaam a IRQ de numero 23, que é a macro dada ao lado

													  //Então temos o seguinte: como queremos a interrupção pelo GPIOD5, então temos que configurar o EXTIO5 (se fosse qualquer outro periférico
													  //teríamos que configurar o acônimo correspondente a ele. Para isso é necessário ver o manual do usuário e pegar a vector table que relaciona
													  //cada periférico com sua IRQ) que tem IRQ number 23 (todos do 5 ao 9, EXTIO9_5 todos estão atrelados ao 23) então é esse número que temos que passar como
													  //parametro para o interrupt Config. Se tudo der certo a função EXTIO9_5_IRQHandler será chamada assim que houver
													  //detecção de borda de trigger no GPIOD5. Basicamente é assim que ocorre uma interrupção em MCUs
    while(1);

    return 0;
}

//Se a interrupção foi confugurada corretamente para o EXTIO0 o processador irá localizar a
//função abaixo
void EXTI0_IRQHandler(void)
{
	//Handle the interruption - Primeiramente a função abaixo irá limpar os registradores de interrupção
	//para ela não ficar infinitamente ativa (o que travaria o código)
	GPIO_IRQHandler(0);
	//A partir daqui escreva o código que rodará assim que a interrupção for detectada
}

void EXTI9_5_IRQHandler(void)
{
	delay2();
	GPIO_IRQHandler(GPIO_PIN_5); //desabilita a interrupção daquele pino para ela não funcionar para sempre
	//Escrever a partir daqui o codigo que vai rodar quando a interrupção for detectada
	ToggleOutputPin(GPIOD, GPIO_PIN_12);
}
